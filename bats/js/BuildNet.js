"use strict";
exports.__esModule = true;
var fs = require("fs");
var path = require("path");
var Const_1 = require("./Const");
var Utils_1 = require("./Utils");
var BuildNet = /** @class */ (function () {
    function BuildNet() {
        this._allCtrls = {};
        this._serviceObjTemp = (0, Utils_1.GetTemplateContent)("ServiceObj");
        this._servicesTemp = (0, Utils_1.GetTemplateContent)("Services");
        this.getAllController();
        this.buildResponse();
        this.buildServiceObj();
        this.buildServices();
    }
    BuildNet.prototype.getAllController = function () {
        var _this = this;
        if (!fs.existsSync(Const_1.NetworkDir))
            return console.log("目录不存在 " + Const_1.NetworkDir);
        var netCtrls = fs.readdirSync(Const_1.NetworkDir).filter(function (v) { return v.endsWith(".d.ts"); });
        netCtrls.forEach(function (fileName) {
            var name = fileName.replace(".d.ts", "");
            var filePath = path.resolve(Const_1.NetworkDir, fileName);
            var fileContent = fs.readFileSync(filePath).toString();
            var matches = fileContent.match(/[\S].*void/g);
            if (matches === null || matches === void 0 ? void 0 : matches.length) {
                _this._allCtrls[name] = matches;
            }
        });
    };
    BuildNet.prototype.buildResponse = function () {
        var _this = this;
        var matches = [];
        Object.keys(this._allCtrls).forEach(function (v) { return matches.push.apply(matches, _this._allCtrls[v]); });
        var data = "/**The class is automatically generated by BatMain.bat , please do not modify */\nexport const enum NetResponse {\n";
        matches.unshift("syncInfo(data: IUserData): void");
        matches.forEach(function (match) {
            var name = match.substring(0, match.trim().indexOf("("));
            var type = match.substring(match.indexOf("(") + 1, match.indexOf(")")).replace("Input", "Output").split(":")[1];
            var temp = (0, Utils_1.UpperFirst)(name);
            // data += `\t/**\n\t * @param ${ type ? "{ " + type.trim() + " }" : "无参" }\n\t */\n`;
            data += "\t/** ".concat(type ? "参数类型：{@link " + type.trim() + "}" : "无参", " */\n");
            data += "\tResponse_".concat(temp, " = \"Response_").concat(temp, "\",\n\n");
        });
        data = data.trim() + "}";
        fs.writeFileSync(Const_1.NetResponsePath, data);
    };
    BuildNet.prototype.buildServiceObj = function () {
        var _this = this;
        var ctrlType = "";
        var content = "";
        Object.keys(this._allCtrls).forEach(function (v, index) {
            ctrlType += index ? " & " + v : v;
            content += "\t".concat(_this._allCtrls[v], " { throw new Error(\"Method not implemented.\"); }\n");
        });
        var data = this._serviceObjTemp.replace(/#controller#/g, ctrlType).replace(/#content#/g, content);
        fs.writeFileSync(Const_1.ServiceObjPath, data.trim());
    };
    BuildNet.prototype.buildServices = function () {
        var content = "";
        Object.keys(this._allCtrls).forEach(function (v) {
            var name = v.substring(1) + "Service";
            content += "export const ".concat(name, " = ServiceInst<").concat(v, ">();\n");
        });
        var data = this._servicesTemp.replace(/#content#/g, content);
        fs.writeFileSync(Const_1.ServicesPath, data.trim());
    };
    return BuildNet;
}());
exports["default"] = BuildNet;
